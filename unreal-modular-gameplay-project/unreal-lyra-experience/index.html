<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unreal Lyra의 Experience 설계 이유</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;700&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Unreal Modular Gameplay 스타일 기반 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #ffffff;
            color: #333;
            line-height: 1.6;
            padding: 40px 20px;
            max-width: 900px;
            margin: 0 auto;
        }

        a {
            color: #0066cc;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        header {
            margin-bottom: 60px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .header-title {
            font-size: 32px;
            font-weight: 400;
            margin-bottom: 10px;
        }

        .header-nav {
            margin-top: 15px;
        }

        .header-nav a {
            margin-right: 20px;
            font-size: 14px;
            color: #0066cc;
        }

        .back-link {
            font-size: 16px;
            margin-bottom: 30px;
            display: inline-block;
        }

        h1 {
            font-size: 36px;
            font-weight: 400;
            margin: 30px 0 20px 0;
            color: #333;
        }

        h2 {
            font-size: 24px;
            font-weight: 400;
            margin: 50px 0 30px 0;
            color: #333;
            padding-bottom: 12px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        h3 {
            font-size: 20px;
            font-weight: 400;
            margin: 40px 0 20px 0;
            color: #333;
            border-bottom: 1px solid #e0e0e0;
        }

        h4 {
            font-size: 18px;
            font-weight: 400;
            margin: 30px 0 15px 0;
            color: #333;
        }

        .post-meta {
            font-size: 16px;
            color: #666;
            margin-bottom: 30px;
        }

        .post-tags span {
            display: inline-block;
            background-color: #e0e0e0;
            color: #666;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 13px;
            margin-right: 8px;
            margin-top: 5px;
        }

        .post-content {
            font-size: 17px;
            color: #444;
            margin-bottom: 60px;
        }

        .post-content p {
            margin-bottom: 1.2em;
        }

        .post-content ul {
            margin-bottom: 1.2em;
            padding-left: 20px;
        }

        .post-content li {
            margin-bottom: 0.8em;
        }

        /* 코드 블록 스타일 */
        .post-content pre {
            background-color: #282c34;
            color: #abb2bf;
            padding: 15px 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 25px 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 15px;
            line-height: 1.4;
        }
        
        .post-content code {
            font-family: 'Roboto Mono', monospace;
            font-size: 1em;
            background-color: #e0e0e0;
            padding: 2px 5px;
            border-radius: 4px;
            color: #c7254e;
        }
        
        .post-content pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
            border-radius: 0;
        }

        /* 표 스타일 */
        .post-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
        }

        .post-content th, .post-content td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .post-content th {
            background-color: #f8f9fa;
            font-weight: 700;
        }

        .post-content tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        footer {
            margin-top: 80px;
            padding-top: 30px;
            border-top: 1px solid #e0e0e0;
            text-align: center;
            font-size: 13px;
            color: #999;
        }

        @media (max-width: 768px) {
            body {
                padding: 30px 15px;
            }

            h1 {
                font-size: 28px;
            }

            h2 {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
     <header>
        <div class="header-title">
            <a href="/">TaehunKim0</a>
        </div>
        <nav class="header-nav">
            <a href="/">Home</a>
            <a href="https://github.com/TaehunKim0" target="_blank">GitHub</a>
        </nav>
    </header>

    <main>
        <article class="post-detail">
            <h1 class="post-title">Lyra의 Experience 설계 이유</h1>
            <div class="post-meta">
                <span class="post-date">2025년 9월 29일</span>
                <div class="post-tags">
                    <span>#UnrealEngine</span>
                    <span>#Lyra</span>
                    <span>#GameFeature</span>
                </div>
            </div>
            <div class="post-content">

                <h2>개요</h2>
                
                <p>언리얼 엔진5 의 라이라 예제에서 Experience 와 GameFeature 를 사용한 모듈형 게임 플레이를 보여주고 있다. 이 예제를 분석해 왜 이렇게 설계했는지 분석해보았다. 회사를 다니면서 협업을 위한 구조와 설계가 굉장히 중요하다는 것을 깨닫고, 언리얼의 GameFeature 플러그인으로 독립적으로 개발하는 것이 정말 좋은 시스템이라고 느꼈다. 이를 파보면서 라이라의 설계 의도를 조금씩 알아간다.</p>

                <br>
                <h2>GameFeature 와 한계</h2>
                

                <image src="./images/GameFeatureAction.png" width="600" height="400">
                <ul>
                    <li>Game Feature 는 Action 들로 구성된다</li>
                    <li>Action 들 중 컴포넌트 추가가 제일 유용한 기능이다</li>
                    <ul>
                        <li>컴포넌트 추가는 월드에 지정한 액터의 서브클래스에 모두 컴포넌트를 추가하는 것이다</li>
                    </ul>

                    <br>
                    <li>컴포넌트를 추가한다는 것은 사실상 원하는 게임 기능을 런타임에 액터에 추가할 수 있다</li>
                    <ul>
                        <li>라이라의 ShooterCore 게임 피처에서는 <code>EquipmentManager</code>, <code>IndicatorManager</code>, <code>InventoryManager</code>, <code>WeaponStateManager</code>, <code>AimAssistManager</code> 등과 같은 핵심 매니저를 액터에 추가했다</li>
                    </ul>

                    <br>
                    <li>그런데… GameFeature에는 Ability 추가 기능이 없다라는 한계가 있다</li>
                    <ul>
                        <li>컴포넌트 추가처럼 어빌리티 추가도 존재할 수 있을 것이라고 생각했는데 존재하지 않는다</li>
                        <li>그렇다면, Ability 를 추가하는 컴포넌트를 추가하는 비직관적인 방식을 사용해야 한다</li>
                        <li>협업 시 기획자/타 프로그래머가 컴포넌트를 추가나 수정하기 어려울 수 있다.</li>
                    </ul>

                    <br>
                    <li>그 이유는 ASC 가 있는지, ASC 위치는 어디인지, 어빌리티 추가 시점 등을 모두 체크하기 힘들기 때문일 것이다</li>
                    <ul>
                        <li>게임 피처는 단순히 전역에 ~~ 한 컴포넌트(기능)를 모두 가지세요~~ 인 것이다</li>
                    </ul>

                    <br>
                    <li>정리하면, 게임 피처는 단순히 게임에 맞는 컴포넌트(기능) 을 모든 캐릭터가 가지세요! 이다</li>
                    <ul>
                        <li>FPS 슈팅 게임이면, FPS 카메라, 장비 관리 시스템, 에임 시스템 등등…</li>
                        <li>TPS 슈팅 게임이면, TPS 카메라 …. 등등</li>
                        <li>여기서 컴포넌트는 각종 매니저가 될 가능성이 높다</li>
                    </ul>

                </ul>

                <br>
                <h2>라이라의 Experience 로 한계 극복</h2>
                

                <ul>
                    <li>라이라는 Experience 라는 데이터 에셋을 사용하며 어빌리티와 외형을 설정할 수 있다.</li>
                    <ul>
                        <li>Experience 는 크게 3가지로 구성된다.</li>
                        <ul>
                            <li>Pawn</li>
                            <li>GameAbility</li>
                            <li>활성화 할 GameFeature</li>
                        </ul>
                    </ul>

                    <br>

                    <li>Experience 는 단순히 게임 모드를 데이터 에셋화 시켰다고 생각하면 된다.</li>
                    <br>

                    <li>하지만 여기서 라이라는 Add Abilities GameFeatureAction 을 커스텀으로 만들었다!</li>
                        <ul>
                            <li>그럼 GameFeature 에서 어빌리티도 추가하면 안돼? 라는 의문이 들 수 있다.</li>
                            <ul>
                                <li>하지만 정작 예제의 GameFeature 들에서는 Add Abilities 액션을 사용하지는 않았다. Experience 에서만 Add Abilities 를 사용하고 있다.</li>
                            </ul>
                            <li>Experience 에서만 Add Abilities 를 사용하고 있다.</li>
                        </ul>

                    <br>

                    <li>또한, Experience 와 Game Feature 둘 다 컴포넌트 추가가 가능하고, 둘 중 한곳만 사용하는 게 아니라 두 곳에서 다른 컴포넌트들을 추가하고 있다.</li>
                    <ul>
                        <li>라이라의 <code>B_ShooterGame_Elimination</code> Experience 는 <code>GameState</code> 에만 컴포넌트를 추가한다.</li>
                        <li>라이라의 <code>B_ShooterGame_ControlPoint</code> Experience 도 그렇다.</li>
                        <img src="./images/B_Shooter_Elimination.png" width="600" height="400">
                        <img src="./images/B_ShooterGame_ControlPoint.png" width="600" height="400">
                        <li>라이라의 <code>ShooterCore</code> 게임 피처는 <code>Character</code>나 <code>Controller</code> 에 대부분 컴포넌트를 추가한다.</li>    
                        <img src="./images/ShooterCore.png" width="600" height="400">
                    </ul>

                    <br>
                    <li><b>그럼 GameFeature 랑 Experience 랑 똑같은 것을 할 수 있는데 왜 분리한걸까?</b></li>

                    <br>
                    <li>Experience 와 GameFeature에 추가된 컴포넌트의 차이는 다음과 같다.</li>
                    <li>왜 이렇게 분리한 것일까?</li>
                     <table>
                    <thead>
                        <tr>
                            <th></th>
                            <th>Experience</th>
                            <th>GameFeature</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>대상</td>
                            <td>주로 <code>GameState</code></td>
                            <td>주로 <code>Character</code>/<code>Controller</code></td>
                        </tr>
                        <tr>
                            <td>목적</td>
                            <td>게임 모드 관련 기능</td>
                            <td>캐릭터 핵심 기능</td>
                        </tr>
                        <tr>
                            <td>예시</td>
                            <td>점수 관리, 팀 관리, 타이머, 리스폰</td>
                            <td>장비, 인벤토리, 카메라</td>
                        </tr>
                    </tbody>
                </table>
                </ul>

                <br>
                <h2>라이라의 Experience 와 GameFeature의 역할 분리</h2>
                
                <h3>역할을 분리한 이유</h3>
                
                <p>라이라는 슈팅 게임 샘플로 제공되었으며, 다음과 같은 특징을 가진다.</p>
                <p>슈팅이라는 장르는 바뀌지 않고, 게임 모드(점령, 데스매치 등) 는 자주 바뀔 수 있다! 따라서, 다음과 같이 분리한 것이다.</p>
                <ul>
                    <li><strong>Experience:</strong> 게임 모드는 자주 바뀜 (매치마다)</li>
                    <li><strong>GameFeature:</strong> 장르 코어는 거의 안 바뀜 (게임 전체에서 공통)</li>
                </ul>

                <h3>Experience (게임 모드 레이어)</h3>
                
                
                <p>"이번 게임은 어떤 룰로 진행되나?”</p>
                <ul>
                    <li> 컴포넌트 : (주로 <code>GameState</code> 에 추가됨)</li>
                    <ul>
                        <li>점수 계산 방식</li>
                        <li>승리 조건</li>
                        <li>팀 구성</li>
                    </ul>
                    <li>Ability 세트 (이 모드에서 쓸 스킬들)</li>
                    <li>사용할 GameFeature 목록</li>
                    <li>예시 :
                        <ul>
                            <li>TeamDeathMatch → 팀 점수 관리</li>
                            <li>ControlPoint → 거점 점령 관리</li>
                        </ul>
                    </li>
                </ul>
                
                <h3>GameFeature (게임 장르/코어 액션)</h3>
                
                <p>"이 게임 장르의 캐릭터는 기본적으로 뭘 할 수 있나?”</p>
                <ul>
                <li>컴포넌트 : (주로 <code>Character</code>/<code>Controller</code> 적용)</li>
                <ul>
                    <li>이동 방식</li>
                    <li>카메라 시스템</li>
                    <li>장비/인벤토리 시스템</li>
                    <li>기본 상호작용</li>
                </ul>
                <li>예시 :
                    <ul>
                        <li>ShooterCore → 총 쏘기, 장비 관리</li>
                        <li>RacingCore → 차량 조종, 부스터</li>
                    </ul>
                </li>
                    
                </ul>

                <br>
                <h2>생각</h2>
                
                <p>라이라를 분석하는 데는 꽤 오랜시간이 걸렸다. 직접 비슷한 구조를 만들면서 진행했다.</p>
                <p>좀 얕게 라이라를 분석하고 나서, 게임 피처는 플러그인 단위로 관리되니까 협업에서 정말 도움이 많이 되겠다라고 생각했다.</p>
                <p>슈팅 게임 외에 RPG, 액션 게임 같은 경우에도 사용하고 싶어서 Experience + GameFeature 를 하나의 게임 모드가 아닌 하나의 캐릭터 또는 적으로 제작하려고 프레임워크를 만들어 보고 있었다.</p>
                <ul>
                    <li>Experience → <code>CharacterDefinition</code> 으로 바꾸고</li>
                    <li>GameFeature → Character 이름 으로 변경해서</li>
                </ul>
                <br>
                <p>캐릭터를 선택하면, <code>CharacterDefinition</code> 안의 Pawn, Ability 가 해당 플레이어에게만 적용되고 GameFeature 도 해당 플레이어에게만 적용된다.</p>
                <br>
                <p>하다보니 현재 <code>CharacterDefinition</code> 과 GameFeature 의 역할의 경계가 모호하다.</p>
                <p>라이라에서도 Experience 와 GameFeature의 역할을 다르게 설정했지만, 강제하지는 않는다. 
                <p>둘 다 같은 기능을 사용할 수 있지만, 우리는 보이지 않는 룰에 따라 역할을 구분했다.</p> 
                <p>실수로 GameFeature 에 장르와 관련된 컴포넌트 말고 다른 것도 넣을 수 있는 것이다.</p>
                <p>실수를 방지할 수 있는 장치를 아직 찾지 못했고 이는 위험하다고 생각이 든다.</p>
                <br>
                <p>내 프로젝트에서는 <code>CharacterDefinition</code> 과 GameFeature 의 역할을 어떻게 하면 좋을지 고민이다.</p>
                <p>또한 전역이 아닌 해당 플레이어에게만 적용되게 하는 필터를 만들어 구현 해놓았지만,</p> 
                <p>기본적인 GameFeature 의 철학에 맞지 않는 건가라는 생각도 든다.</p>
                <br>
                <p><b>최종 목표는 게임 피처(플러그인) 단위로 개발자가 독립적으로 개발하는 것이다.</b></p>
                <p>글로 작성된 규칙보다는 코딩 단계에서 실수를 방지하는 해결책이 있는 것이 좋다고 생각한다.</p>
                <p>쉬운 예시로 언어 차원에서도 기본 생성자를 제거하고, 의도된 대로 초기화하는 커스텀 생성자를 만들 수 있도록 하여 실수를 줄일 수 있다.</p>
                <p>좀 더 고민할 필요가 있다.</p>

            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2025 [TaehunKim0]. All rights reserved.</p>
    </footer>
</body>
</html>